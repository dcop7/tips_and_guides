# Disclaimer
This repository contains information collected from various online sources and/or generated by AI assistants. The content provided here is for informational purposes only and is intended to serve as a general reference on various topics.

# MongoDB Data Modeling Best Practices

## Table of Contents

1. [Introduction](#introduction)
2. [Fundamental Principles of NoSQL Data Modeling](#fundamental-principles-of-nosql-data-modeling)
3. [Document Structure & Schema Design](#document-structure--schema-design)
4. [Relationships & Embedding Strategies](#relationships--embedding-strategies)
5. [Schema Validation](#schema-validation)
6. [Indexing Strategies](#indexing-strategies)
7. [Denormalization & Performance Optimization](#denormalization--performance-optimization)
8. [Sharding & Scaling Considerations](#sharding--scaling-considerations)
9. [Common Patterns & Use Cases](#common-patterns--use-cases)
10. [Security Best Practices](#security-best-practices)
11. [Common Pitfalls & Anti-Patterns](#common-pitfalls--anti-patterns)
12. [References](#references)

## Introduction

MongoDB is a document-oriented NoSQL database that stores data in flexible, JSON-like documents. Unlike relational databases, MongoDB's schema-free approach allows documents to have different structures within the same collection, which provides flexibility but requires careful design.

This guide covers MongoDB data modeling best practices, focusing on when and how to embed or reference data, optimize for read/write patterns, and ensure scalability across distributed systems.

## Fundamental Principles of NoSQL Data Modeling

### Key Differences from Relational Databases

- **Schema Flexibility**: No fixed schema; documents in a collection can have different fields
- **No Joins**: Traditional joins don't exist in MongoDB (though `$lookup` provides limited join capability)
- **Denormalization**: Data is often duplicated to avoid expensive joins
- **Access Pattern Focus**: Design based on how data is accessed, not just how it's structured

### Data Modeling Process

1. **Analyze Application Requirements**:
   - Query patterns (read vs. write ratio)
   - Access frequency
   - Consistency requirements
   - Scaling needs

2. **Design Document Structures**:
   - Determine embed vs. reference relationships
   - Balance normalization and denormalization

3. **Validate with Real-World Tests**:
   - Benchmark with realistic data volumes
   - Adjust based on performance metrics

## Document Structure & Schema Design

### Basic Document Anatomy

```json
{
  "_id": ObjectId("5f8d0c1b9d3b9e001c390a7c"),
  "username": "johndoe",
  "email": "john@example.com",
  "profile": {
    "firstName": "John",
    "lastName": "Doe",
    "age": 30
  },
  "tags": ["developer", "mongodb", "javascript"],
  "created_at": ISODate("2020-10-19T10:30:00Z")
}
```

### Naming Conventions

- Use camelCase for field names
- Be consistent and descriptive
- Avoid prefixes for field types (no "strName" or "intAge")
- Use meaningful names for collections (typically plural nouns)

### Field Types & Best Practices

- Use appropriate BSON types:
  - `ObjectId` for unique identifiers
  - `Date` for timestamps (not string representations)
  - `Decimal128` for financial calculations
  - `Boolean` for true/false values (not 0/1 integers)

- Design for document growth:
  - Set appropriate padding factor
  - Consider fields that will grow (arrays, nested objects)

## Relationships & Embedding Strategies

### Embedding vs. Referencing

**Embedding** (Denormalized):
```json
// Customer document with embedded addresses
{
  "_id": ObjectId("5f8d0c1b9d3b9e001c390a7c"),
  "name": "John Doe",
  "email": "john@example.com",
  "addresses": [
    {
      "type": "home",
      "street": "123 Main St",
      "city": "Springfield",
      "state": "IL",
      "zip": "62701"
    },
    {
      "type": "work",
      "street": "456 Business Ave",
      "city": "Springfield",
      "state": "IL",
      "zip": "62704"
    }
  ]
}
```

**Referencing** (Normalized):
```json
// Customer document
{
  "_id": ObjectId("5f8d0c1b9d3b9e001c390a7c"),
  "name": "John Doe",
  "email": "john@example.com",
  "address_ids": [
    ObjectId("5f8d0c1b9d3b9e001c390a7d"),
    ObjectId("5f8d0c1b9d3b9e001c390a7e")
  ]
}

// Address documents
{
  "_id": ObjectId("5f8d0c1b9d3b9e001c390a7d"),
  "customer_id": ObjectId("5f8d0c1b9d3b9e001c390a7c"),
  "type": "home",
  "street": "123 Main St",
  "city": "Springfield",
  "state": "IL",
  "zip": "62701"
}
```

### When to Embed vs. Reference

**Embed when**:
- "Contains" relationship exists
- Data is accessed together most of the time
- Embedded data is relatively small
- Embedded data doesn't grow unbounded
- Atomicity is required

**Reference when**:
- Many-to-many relationships
- Large subdocuments (MBs in size)
- Data accessed independently
- Data changes frequently
- Document would exceed 16MB limit

### One-to-Many Relationship Patterns

1. **Embed subdocuments** (few subdocuments):
```json
{
  "_id": ObjectId("..."),
  "title": "MongoDB Course",
  "instructor": "John Smith",
  "modules": [
    { "title": "Introduction", "duration": 60 },
    { "title": "Basic CRUD", "duration": 120 },
    { "title": "Aggregation", "duration": 90 }
  ]
}
```

2. **Array of references** (many subdocuments):
```json
// Course document
{
  "_id": ObjectId("course123"),
  "title": "MongoDB Course",
  "instructor": "John Smith",
  "module_ids": [ObjectId("mod1"), ObjectId("mod2"), ObjectId("mod3")]
}

// Module collection
{
  "_id": ObjectId("mod1"),
  "course_id": ObjectId("course123"),
  "title": "Introduction",
  "duration": 60
}
```

3. **Parent reference** (for hierarchical data):
```json
[
  { "_id": ObjectId("node1"), "name": "Root", "parent_id": null },
  { "_id": ObjectId("node2"), "name": "Child 1", "parent_id": ObjectId("node1") },
  { "_id": ObjectId("node3"), "name": "Child 2", "parent_id": ObjectId("node1") }
]
```

### Many-to-Many Relationship Patterns

1. **Array of references on both sides**:
```json
// Authors
{
  "_id": ObjectId("author1"),
  "name": "John Doe",
  "book_ids": [ObjectId("book1"), ObjectId("book2")]
}

// Books
{
  "_id": ObjectId("book1"),
  "title": "MongoDB Basics",
  "author_ids": [ObjectId("author1"), ObjectId("author2")]
}
```

2. **Intermediate collection**:
```json
// Author-Book relationship
{
  "_id": ObjectId("rel1"),
  "author_id": ObjectId("author1"),
  "book_id": ObjectId("book1"),
  "contribution_type": "Primary Author"
}
```

## Schema Validation

MongoDB allows optional schema validation using JSON Schema:

```javascript
db.createCollection("customers", {
  validator: {
    $jsonSchema: {
      bsonType: "object",
      required: ["name", "email", "created_at"],
      properties: {
        name: {
          bsonType: "string",
          description: "must be a string and is required"
        },
        email: {
          bsonType: "string",
          pattern: "^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$",
          description: "must be a valid email address"
        },
        phone: {
          bsonType: "string",
          description: "must be a string if provided"
        },
        created_at: {
          bsonType: "date",
          description: "must be a date and is required"
        }
      }
    }
  },
  validationLevel: "moderate",
  validationAction: "error"
})
```

Best practices:
- Start with lenient validation and tighten gradually
- Consider `validationLevel: "moderate"` to allow existing documents
- Use `validationAction: "warn"` during development

## Indexing Strategies

### Index Types

1. **Single Field Index**:
```javascript
db.users.createIndex({ email: 1 })
```

2. **Compound Index**:
```javascript
db.orders.createIndex({ customer_id: 1, order_date: -1 })
```

3. **Multikey Index** (for arrays):
```javascript
db.products.createIndex({ tags: 1 })
```

4. **Text Index**:
```javascript
db.articles.createIndex({ title: "text", content: "text" })
```

5. **Geospatial Index**:
```javascript
db.places.createIndex({ location: "2dsphere" })
```

6. **Hashed Index**:
```javascript
db.collection.createIndex({ _id: "hashed" })
```

### Indexing Best Practices

- Create indexes that support your queries
- Use compound indexes for queries with multiple conditions
- Put equality conditions before range conditions in compound indexes
- Use covered queries where possible
- Be cautious about indexing high-cardinality arrays
- Consider query selectivity when ordering index fields
- Monitor and remove unused indexes

## Denormalization & Performance Optimization

### Patterns for Denormalization

1. **Computed Pattern**: Pre-compute and store values
```javascript
{
  "_id": ObjectId("order123"),
  "items": [
    { "product_id": ObjectId("prod1"), "price": 10.99, "quantity": 2 },
    { "product_id": ObjectId("prod2"), "price": 24.99, "quantity": 1 }
  ],
  "total_price": 46.97  // Pre-computed total
}
```

2. **Subset Pattern**: Store subset of fields from related document
```javascript
{
  "_id": ObjectId("order123"),
  "customer_id": ObjectId("cust456"),
  "customer_info": {
    "name": "Jane Smith",  // Duplicated from customer document
    "email": "jane@example.com"
  }
}
```

3. **Extended Reference Pattern**: Store frequently accessed fields
```javascript
{
  "_id": ObjectId("comment123"),
  "post_id": ObjectId("post456"),
  "post_title": "MongoDB Data Modeling",  // Frequently accessed
  "author_id": ObjectId("user789"),
  "author_name": "John Doe",  // Frequently accessed
  "text": "Great article!"
}
```

### When to Denormalize

- High read/write ratio (read-heavy workload)
- Data doesn't change frequently
- Faster reads are critical for the application
- Join-heavy operations affect performance

### Handling Document Growth

- Use pre-allocation for fields expected to grow
- Monitor document size over time
- Set `powerOf2Sizes: true` for collections with frequent updates
- Consider references for large or growing arrays

## Sharding & Scaling Considerations

### Choosing a Shard Key

Good shard keys provide:
- **High cardinality**: Many possible values
- **Even distribution**: Prevents hotspots
- **No monotonic increase**: Avoids concentration of writes

Examples:
```javascript
// Compound shard key for user events
sh.shardCollection("app.events", { user_id: 1, timestamp: 1 })

// Hashed shard key for even distribution
sh.shardCollection("app.logs", { _id: "hashed" })
```

### Schema Design for Sharded Collections

- Include shard key in all queries for targeted operations
- Avoid scatter-gather queries (queries without the shard key)
- Consider how data grows over time
- Be cautious with unique indexes across shards

## Common Patterns & Use Cases

### Time Series Data

```javascript
{
  "_id": ObjectId("..."),
  "device_id": "sensor-123",
  "timestamp": ISODate("2023-05-15T10:30:00Z"),
  "readings": {
    "temperature": 23.5,
    "humidity": 45.2,
    "pressure": 1013
  },
  "metadata": {
    "location": "Building A",
    "floor": 3
  }
}
```

Best practices:
- Use TTL indexes for automatic data expiration
- Consider time-based partitioning
- Pre-aggregate historical data

### Catalog/Product Data

```javascript
{
  "_id": ObjectId("prod123"),
  "sku": "MDB-SHIRT-L",
  "title": "MongoDB T-Shirt",
  "description": "Official MongoDB merchandise",
  "price": 25.99,
  "category_id": ObjectId("cat456"),
  "category_name": "Apparel",  // Denormalized for read performance
  "attributes": {
    "size": "Large",
    "color": "Blue",
    "material": "Cotton"
  },
  "variants": [
    { "sku": "MDB-SHIRT-M", "size": "Medium", "inventory": 45 },
    { "sku": "MDB-SHIRT-XL", "size": "X-Large", "inventory": 30 }
  ],
  "tags": ["clothing", "mongodb", "merchandise"],
  "created_at": ISODate("2023-01-15T12:00:00Z"),
  "updated_at": ISODate("2023-02-20T09:15:00Z")
}
```

### Social Media Content

```javascript
{
  "_id": ObjectId("post123"),
  "author_id": ObjectId("user456"),
  "author": {
    "username": "mongodb_fan",
    "display_name": "MongoDB Enthusiast",
    "avatar_url": "https://example.com/avatar.jpg"
  },
  "content": "Just learned about schema design in MongoDB!",
  "posted_at": ISODate("2023-05-10T14:30:00Z"),
  "likes_count": 42,
  "comments_count": 7,
  "tags": ["mongodb", "database", "learning"]
}
```

## Security Best Practices

### Field-Level Encryption

```javascript
// Client-side code
const clientEncryption = new ClientEncryption(client, {
  keyVaultNamespace: "encryption.__keyVault",
  kmsProviders: {
    local: { key: localMasterKey }
  }
});

// Insert with encrypted fields
await collection.insertOne({
  name: "John Smith",
  ssn: clientEncryption.encrypt(
    "123-45-6789",
    { algorithm: "AEAD_AES_256_CBC_HMAC_SHA_512-Deterministic" }
  ),
  dob: clientEncryption.encrypt(
    new Date("1990-01-01"),
    { algorithm: "AEAD_AES_256_CBC_HMAC_SHA_512-Random" }
  )
});
```

### Role-Based Access Control

```javascript
// Create a read-only role for reporting
db.createRole({
  role: "readOnly",
  privileges: [
    { resource: { db: "sales", collection: "" }, actions: ["find"] }
  ],
  roles: []
});

// Create an analytics user
db.createUser({
  user: "analytics",
  pwd: "securePassword",
  roles: ["readOnly"]
});
```

## Common Pitfalls & Anti-Patterns

1. **Excessive Embedding**: Creating deeply nested documents that are hard to query
2. **Unbounded Arrays**: Arrays that grow indefinitely and exceed document size limits
3. **Improper Indexing**: Creating too many or wrong indexes
4. **Monotonically Increasing Shard Keys**: Causing write hotspots
5. **Treating MongoDB Like a Relational Database**: Overusing normalization
6. **Ignoring Document Size Limits**: Not planning for the 16MB maximum document size
7. **Schema Inconsistency**: Inconsistent field names or types across documents
8. **Inefficient Queries**: Not using proper filters or projections

## References

- [MongoDB Data Modeling Documentation](https://www.mongodb.com/docs/manual/core/data-modeling-introduction/)
- [MongoDB Schema Design Patterns](https://www.mongodb.com/blog/post/building-with-patterns-a-summary)
- [MongoDB University: Data Modeling Course](https://learn.mongodb.com/)
